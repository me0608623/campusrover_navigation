#include <ros/ros.h>
#include <math.h>
#include <iostream>
#include <Eigen/Dense>

#include <geometry_msgs/Twist.h>
#include <geometry_msgs/Pose.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/PoseArray.h>

#include <nav_msgs/Path.h>
#include <nav_msgs/OccupancyGrid.h>

#include <tf/transform_broadcaster.h>
#include <tf/transform_listener.h>
#include <tf/tf.h>
#include <tf2_ros/transform_broadcaster.h>
#include <tf2_ros/transform_listener.h>
#include <tf/transform_datatypes.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>
#include <sensor_msgs/Joy.h>
#include <sensor_msgs/LaserScan.h>
#include <nav_msgs/Odometry.h>

#include <costmap_converter/ObstacleMsg.h>
#include <costmap_converter/ObstacleArrayMsg.h>

#include <visualization_msgs/Marker.h>
#include <visualization_msgs/MarkerArray.h>

#include <campusrover_msgs/PlannerFunction.h>
#include <campusrover_msgs/ElevatorStatusChecker.h>
#include <campusrover_move/PullOverPathGenerator.h>

#define M_PI 3.14159265358979323846  /* pi */
using namespace std;


ros::Subscriber elevator_path_sub_, global_path_sub_, costmap_sub_, odom_sub_, click_sub_, custom_obst_sub_;
ros::Publisher twist_pub_, twist_path_pub_, path_marker_pub_, global_status_check_pub_;
ros::ServiceClient elevator_status_check_client_, global_status_check_client_, dwa_planner_client_, pullover_planner_client_;

ros::Time planner_start_time;

nav_msgs::Path following_path_;
nav_msgs::Path globle_path_; 
nav_msgs::Path elevator_path_; 
nav_msgs::Path pullover_path_;
geometry_msgs::PoseStamped target_pose_;
nav_msgs::OccupancyGrid costmap_data_;

geometry_msgs::Pose robot_tf_pose_;
geometry_msgs::PoseArray obstacle_poses_;

campusrover_msgs::ElevatorStatusChecker elevator_status_checker_msg_;
std_msgs::Empty global_status_checker_msg_;


string robot_frame_;
int status_msg_;
int path_sub_mode_;

double arriving_range_dis_;
double arriving_range_angle_;

bool action_flag_ = false;
bool get_following_path_ = false;
bool get_costmap_data_ = false;
bool get_obstacle_data_ = false;
bool obstacle_stop_cmd_ = false;
bool arriving_end_point_= false;
bool arriving_end_direction_= false;
bool enble_costmap_obstacle_;
bool direction_inverse_= false;
bool get_velocity_data_ = false;

bool call_dwa_enable_srv_ = false;
bool call_dwa_disable_srv_ = true;


bool enable_linear_depend_angular_;
bool enble_dwa_obstacle_avoidance_;
bool enble_pullover_mode_;
double max_angle_of_linear_profile_;
double min_angle_of_linear_profile_;

double threshold_occupied_;
double footprint_max_x_;
double footprint_min_x_;
double footprint_max_y_;
double footprint_min_y_;

double robot_yaw_;
double speed_pid_k_;
double target_yaw_;

double max_linear_velocity_;
double min_linear_velocity_;
double max_angular_velocity_;
double min_angular_velocity_;
double target_point_dis_;
double obstacle_detect_max_dis_;
double obstacle_detect_min_dis_;
double back_obstacle_detect_max_dis_;
double obstacle_range_;

double active_angular_;

double twist_linear_step_ = 0;
double twist_angular_step_ = 0;

double current_v_;
double current_w_;

void TwistPublish(double x, double z);
void moving_to_target_point();
void moving_to_target_direction();
void angle_normalize(double &angle);
void ElevatorStatusCheckCallService(ros::ServiceClient &client,campusrover_msgs::ElevatorStatusChecker &srv);
void TwistProfile(double &profile_linear_x, double &profile_angular_z);
void UpdateInputPath(const nav_msgs::Path &path);
void PulloverFunction();
//-----------------------------------------------------------------------------------------------
void get_parameters(ros::NodeHandle n_private)
{
  n_private.param<string>("robot_frame", robot_frame_, "base_link");
  n_private.param<double>("arriving_range_dis", arriving_range_dis_, 0.2);
  n_private.param<double>("arriving_range_angle", arriving_range_angle_, 0.1);

  n_private.param<double>("max_linear_velocity", max_linear_velocity_, 0.5);
  n_private.param<double>("min_linear_velocity", min_linear_velocity_, 0.05);
  n_private.param<double>("max_angular_velocity", max_angular_velocity_, 0.3);
  n_private.param<double>("min_angular_velocity", min_angular_velocity_, 0.05);
  n_private.param<double>("target_point_dis", target_point_dis_, 0.5);

  n_private.param<double>("threshold_occupied", threshold_occupied_, 10);
  n_private.param<double>("footprint_max_x", footprint_max_x_, 1.5);
  n_private.param<double>("footprint_min_x", footprint_min_x_, -0.5);
  n_private.param<double>("footprint_max_y", footprint_max_y_, 0.5);
  n_private.param<double>("footprint_min_y", footprint_min_y_, -0.5);
  n_private.param<double>("obstacle_range", obstacle_range_, 0.3);
  n_private.param<double>("obstacle_detect_max_dis", obstacle_detect_max_dis_, 1.5);
  n_private.param<double>("obstacle_detect_min_dis", obstacle_detect_min_dis_, 0.8);
  n_private.param<double>("back_obstacle_detect_max_dis", back_obstacle_detect_max_dis_, 2.3);
  n_private.param<double>("speed_pid_k", speed_pid_k_, 0.06);

  n_private.param<double>("min_angle_of_linear_profile", min_angle_of_linear_profile_, 0.1);
  n_private.param<double>("max_angle_of_linear_profile", max_angle_of_linear_profile_, 0.5);

  n_private.param<bool>("enble_costmap_obstacle", enble_costmap_obstacle_, false);
  n_private.param<bool>("enble_dwa_obstacle_avoidance", enble_dwa_obstacle_avoidance_, false);
  n_private.param<bool>("enble_pullover_mode", enble_pullover_mode_, false);
  n_private.param<bool>("direction_inverse", direction_inverse_, false);
  n_private.param<bool>("enable_linear_depend_angular", enable_linear_depend_angular_, false);
}

//-----------------------------------------------------------------------------------------------
void UpdateCampusRoverPoseFromTF()
{
  static tf2_ros::Buffer tfBuffer;
  static tf2_ros::TransformListener tfListener(tfBuffer);
  static geometry_msgs::TransformStamped transformStamped;
  static double roll, pitch, yaw;
  static double pre_yaw;

  try
  {
    transformStamped = tfBuffer.lookupTransform(following_path_.header.frame_id, robot_frame_, ros::Time(0), ros::Duration(2));
  }
  catch (tf2::TransformException &ex)
  {
    ROS_WARN(" %s. Can't update pose from TF, for that will be use the latest source point.", ex.what());
  }

  robot_tf_pose_.position.x = transformStamped.transform.translation.x;
  robot_tf_pose_.position.y = transformStamped.transform.translation.y;
  robot_tf_pose_.position.z = transformStamped.transform.translation.z;
  robot_tf_pose_.orientation.x = transformStamped.transform.rotation.x;
  robot_tf_pose_.orientation.y = transformStamped.transform.rotation.y;
  robot_tf_pose_.orientation.z = transformStamped.transform.rotation.z;
  robot_tf_pose_.orientation.w = transformStamped.transform.rotation.w;

  tf::Quaternion q( robot_tf_pose_.orientation.x,
                    robot_tf_pose_.orientation.y,
                    robot_tf_pose_.orientation.z,
                    robot_tf_pose_.orientation.w);
  tf::Matrix3x3 m(q);
  
  m.getRPY(roll, pitch, yaw);
  if(!direction_inverse_)
  {
    pre_yaw = yaw;
  }
  else
  {
    pre_yaw = yaw+M_PI;
    angle_normalize(pre_yaw);
  }
  robot_yaw_ = pre_yaw;

  // std::cout << "arriving_end_point_ : " << arriving_end_point_<< " arriving_end_dir : "<< arriving_end_direction_<<'\n';
  
}
//-----------------------------------------------------------------------------------------------
void check_arrive_point()
{
  static double dist;

  dist = sqrt(pow(target_pose_.pose.position.x - robot_tf_pose_.position.x, 2)
              + pow(target_pose_.pose.position.y - robot_tf_pose_.position.y, 2));

  if(dist < arriving_range_dis_ )
  {
    arriving_end_point_ = true;
    twist_linear_step_ = 0;
  }else{
    arriving_end_point_ = false;
    arriving_end_direction_ = false;
  }
  // std::cout << "arriving_end_point_ : " << arriving_end_point_<< "path_sub_mode_ : " << path_sub_mode_<<'\n';
}
//-----------------------------------------------------------------------------------------------
void check_arrive_direction()
{
  static double angle_error;
  static double roll, pitch, yaw;
  
  angle_error = target_yaw_ - robot_yaw_;

  angle_normalize(angle_error);

  //cout<< "target_yaw_ : " << target_yaw_<<" robot_yaw_"<<robot_yaw_<<" angle_error"<<angle_error<<endl;

  if(abs(angle_error) < arriving_range_angle_)
  {
    arriving_end_direction_ = true;
    if(path_sub_mode_ == campusrover_msgs::PlannerFunction::Request::MODE_ELEVATOR_PATH)
    {
      elevator_status_checker_msg_.request.node_name.data = "planner";
      elevator_status_checker_msg_.request.status.data = arriving_end_direction_;
      ElevatorStatusCheckCallService(elevator_status_check_client_, elevator_status_checker_msg_);
    }
    else if(path_sub_mode_ == campusrover_msgs::PlannerFunction::Request::MODE_GLOBAL_PATH)
    {
      global_status_check_pub_.publish(global_status_checker_msg_);
    }
    twist_angular_step_ = 0;
    
  }else{
    arriving_end_direction_ = false;
  }
  

}
//----------------------------------------------------------------------------------------------

void TimerCallback(const ros::TimerEvent &event)
{
  if(!action_flag_)
    return;
    
  // if (obstacle_stop_cmd_ )
  // {
  //   TwistPublish(0.0, 0.0);
  //   return;
  // }

  if(path_sub_mode_ == campusrover_msgs::PlannerFunction::Request::MODE_BUTTON_PARKING)
  {
    TwistPublish(max_linear_velocity_, active_angular_);
  }
  else
  {
    if (get_following_path_)
    {
      if (get_costmap_data_ || get_obstacle_data_|| !enble_costmap_obstacle_)
      {
        UpdateCampusRoverPoseFromTF();
        if(enble_pullover_mode_ & !call_dwa_enable_srv_)
        {
          PulloverFunction();
        }
        if(!arriving_end_direction_)
        {
          if(!arriving_end_point_)
          {
            check_arrive_point();
            if(arriving_end_point_)
            {
              moving_to_target_direction();
              return;
            }
            moving_to_target_point();
          }
          else
          {
            check_arrive_direction();
            if(arriving_end_direction_)
            {
              status_msg_ = 4;
              TwistPublish(0.0, 0.0);
              return;
            }

            moving_to_target_direction();
          }
        }
        else
        {
          check_arrive_point();
          status_msg_ = 4;
          TwistPublish(0.0, 0.0);
          
        }
      }
      else
      {
        status_msg_ = 2;
        TwistPublish(0.0, 0.0);
      }
    }
    else
    {
      status_msg_ = 1;
      TwistPublish(0.0, 0.0);
    }
  }

}
//-----------------------------------------------------------------------------------------------
void msgs_timerCallback(const ros::TimerEvent &event)
{
  //std::cout << "parameter[arriving_range] :  " << arriving_range_<< '\n';
  if (status_msg_ == 1)
  {
    ROS_WARN("path following : Without Globle Path to follow, Waiting for the Path input");
    status_msg_ = 0;
  }
  else if (status_msg_ == 2)
  {
    ROS_WARN("path following : Without costmap input , Waiting for the costmap input");
    status_msg_ = 0;
  }
  else if (status_msg_ == 3)
  {
    ROS_INFO("path following : detect obstacle");
    status_msg_ = 0;
  }
  else if (status_msg_ == 4)
  {
    ROS_INFO("path following : Arrival the destination");
    status_msg_ = 0;
  }
  else
  {
    //ROS_INFO("dp planner : PEV moving");
    status_msg_ = 0;
  }

}
//-----------------------------------------------------------------------------------------------
void moving_to_target_point()
{
  //find close point from globle path

  static double x_p ,y_p;
  static double dist_fp_p;
  static double closest_dist;
  static int closest_id;

  static double x_fp, y_fp;
  static double looking_dist;
  static double ob_dist;
  static double front_ob_closest_dis;
  static double back_ob_closest_dis;
  static int target_point_id;
  static int front_ob_detect_id;
  static int back_ob_detect_id;
  geometry_msgs::PoseStamped target_pose;

  for (int cp = 0; cp < following_path_.poses.size(); cp++)
  {
    x_p = following_path_.poses[cp].pose.position.x;
    y_p = following_path_.poses[cp].pose.position.y;
    dist_fp_p = sqrt(pow(robot_tf_pose_.position.x - x_p,2) + pow(robot_tf_pose_.position.y - y_p,2));
    if (cp == 0)
    {
      closest_dist = dist_fp_p;
      closest_id = cp;
    }
    else if (dist_fp_p < closest_dist)
    {
      closest_dist = dist_fp_p;
      closest_id = cp;
    }
  }
  
  //std::cout << "closest_id : " << closest_id<<" new_path_ : " << new_path_<<'\n';
  target_point_id = closest_id;
  front_ob_detect_id = closest_id;
  back_ob_detect_id = closest_id;
  if (closest_id < following_path_.poses.size() - 1)
  {
    //find the target point from globle path for following
    for(int fp = closest_id;fp<following_path_.poses.size();fp++)
    {
      looking_dist = sqrt(pow(following_path_.poses[fp].pose.position.x - robot_tf_pose_.position.x, 2) 
                        + pow(following_path_.poses[fp].pose.position.y - robot_tf_pose_.position.y, 2));

      if(looking_dist <= target_point_dis_)
      {
        target_point_id = fp;
      }

      if(looking_dist <= obstacle_detect_max_dis_)
      {
        front_ob_detect_id = fp;
      }
      else
      {
        break;
      }
    }
  }

  // if(closest_id > 0)
  // {
  //   for(int p = closest_id; p > 0;p--)
  //   {
  //     looking_dist = sqrt(pow(following_path_.poses[p].pose.position.x - robot_tf_pose_.position.x, 2) 
  //                       + pow(following_path_.poses[p].pose.position.y - robot_tf_pose_.position.y, 2));
      
  //     if(looking_dist <= back_obstacle_detect_max_dis_)
  //     {
  //       back_ob_detect_id = p;
  //     }
  //     else
  //     {
  //       break;
  //     }
  //   }
  // }
    
  
  // cout<<"target_point_id: "<<target_point_id<<"front_ob_detect_id: "<<front_ob_detect_id<<endl;

  target_pose.header.frame_id = following_path_.header.frame_id;
  target_pose.pose.position.x = following_path_.poses[target_point_id].pose.position.x;
  target_pose.pose.position.y = following_path_.poses[target_point_id].pose.position.y;
  target_pose.pose.position.z = following_path_.poses[target_point_id].pose.position.z;

  geometry_msgs::PoseStamped following_path_pose_g;
  geometry_msgs::PoseStamped following_path_pose_b;
  static tf2_ros::Buffer tfBuffer;
  static tf2_ros::TransformListener tfListener(tfBuffer);

  static ros::Time detect_static_ob_first_time ; 
  static ros::Time no_detect_ob_first_time;
  double detect_ob_continue_time;
  double no_detect_ob_continue_time;

  bool detect_front_obstacle = false;
  static bool detect_front_obstacled = false;
  static bool detect_static_obstacled = false;

  // bool detect_back_obstacle = false;
  // static bool detect_back_obstacled = false;

  //seach in front of robot obstacles
  for(int path_count=closest_id; path_count<front_ob_detect_id; path_count++)
  {
    if(detect_front_obstacle){
      break;
    }
    following_path_pose_g.header.frame_id = following_path_.header.frame_id;
    following_path_pose_g.pose.position.x = following_path_.poses[path_count].pose.position.x;
    following_path_pose_g.pose.position.y = following_path_.poses[path_count].pose.position.y;
    following_path_pose_g.pose.position.z = following_path_.poses[path_count].pose.position.z;
    try{
      tfBuffer.transform(following_path_pose_g, following_path_pose_b, robot_frame_, ros::Duration(2.0));
    }
    catch (tf2::TransformException &ex){
      ROS_WARN("ob : %s", ex.what());
      return;
    }
    for(int ob_count=0; ob_count < obstacle_poses_.poses.size(); ob_count++)
    {
      ob_dist = sqrt(pow(following_path_pose_b.pose.position.x - obstacle_poses_.poses[ob_count].position.x, 2) 
                    + pow(following_path_pose_b.pose.position.y - obstacle_poses_.poses[ob_count].position.y, 2));
      
      if(ob_dist < obstacle_range_){
        front_ob_closest_dis = sqrt(pow(following_path_pose_b.pose.position.x , 2) 
                            + pow(following_path_pose_b.pose.position.y , 2));;
        
        detect_front_obstacle = true;
        
        // cout<<"closest_id: "<<closest_id<<"front_ob_detect_id: "<<front_ob_detect_id<<"path_count: "<<path_count<<endl;
        break;
      }
    }
  }

  //seach back of robot obstacles
  // int gp_closest_id;
  // for (int cp = 0; cp < globle_path_.poses.size(); cp++)
  // {
  //   x_p = globle_path_.poses[cp].pose.position.x;
  //   y_p = globle_path_.poses[cp].pose.position.y;
  //   dist_fp_p = sqrt(pow(robot_tf_pose_.position.x - x_p,2) + pow(robot_tf_pose_.position.y - y_p,2));
  //   if (cp == 0)
  //   {
  //     closest_dist = dist_fp_p;
  //     gp_closest_id = cp;
  //   }
  //   else if (dist_fp_p < closest_dist)
  //   {
  //     closest_dist = dist_fp_p;
  //     gp_closest_id = cp;
  //   }
  // }

  // for(int path_count=gp_closest_id; path_count>back_ob_detect_id; path_count--)
  // {
  //   if(detect_back_obstacle){
  //     break;
  //   }
  //   following_path_pose_g.header.frame_id = globle_path_.header.frame_id;
  //   following_path_pose_g.pose.position.x = globle_path_.poses[path_count].pose.position.x;
  //   following_path_pose_g.pose.position.y = globle_path_.poses[path_count].pose.position.y;
  //   following_path_pose_g.pose.position.z = globle_path_.poses[path_count].pose.position.z;
  //   try{
  //     tfBuffer.transform(following_path_pose_g, following_path_pose_b, robot_frame_, ros::Duration(2.0));
  //   }
  //   catch (tf2::TransformException &ex){
  //     ROS_WARN("ob : %s", ex.what());
  //     return;
  //   }
  //   for(int ob_count=0; ob_count < obstacle_poses_.poses.size(); ob_count++)
  //   {
  //     ob_dist = sqrt(pow(following_path_pose_b.pose.position.x - obstacle_poses_.poses[ob_count].position.x, 2) 
  //                   + pow(following_path_pose_b.pose.position.y - obstacle_poses_.poses[ob_count].position.y, 2));
      
  //     if(ob_dist < obstacle_range_){
  //       back_ob_closest_dis = sqrt(pow(following_path_pose_b.pose.position.x , 2) 
  //                           + pow(following_path_pose_b.pose.position.y , 2));;
        
  //       detect_back_obstacle = true;
        
  //       // cout<<"closest_id: "<<closest_id<<"front_ob_detect_id: "<<front_ob_detect_id<<"path_count: "<<path_count<<endl;
  //       break;
  //     }
  //   }
  // }

  static double direction_yaw;
  static double yaw_error;
  static double ang_vel;
  static double len_vel;


  direction_yaw = atan2(target_pose.pose.position.y - robot_tf_pose_.position.y, target_pose.pose.position.x - robot_tf_pose_.position.x);
  
  yaw_error = direction_yaw - robot_yaw_;
  angle_normalize(yaw_error);

  ang_vel = yaw_error*speed_pid_k_;

  if(direction_inverse_)
  {
    len_vel = -max_linear_velocity_;
  }
  else
  {
    len_vel = max_linear_velocity_;
  }

  //DWA Obstacle Avoidance 
  if(enble_dwa_obstacle_avoidance_)
  {
    //detect obstacle process
    if(detect_front_obstacle)
    {
      if(!detect_front_obstacled)
      {
        detect_front_obstacled = true;
      }

      if((front_ob_closest_dis - obstacle_detect_min_dis_)/(obstacle_detect_max_dis_ - obstacle_detect_min_dis_) < 0.1)
      {
        if(!detect_static_obstacled)
        {
          detect_static_ob_first_time = ros::Time::now();
          detect_static_obstacled = true;
        }
        ros::Time time_now = ros::Time::now();
        detect_ob_continue_time = time_now.toSec()- detect_static_ob_first_time.toSec();
      }
      else
      {
        if(detect_static_obstacled)
        {
          detect_static_obstacled = false;
        }
      }
      
      // std::cout << "detect_ob_continue_time " <<detect_ob_continue_time<< std::endl;
      if(detect_static_obstacled && detect_ob_continue_time > 4.0)
      {
        if(!call_dwa_enable_srv_)
        {
          campusrover_msgs::PlannerFunction dwa_planner_srv;
          dwa_planner_srv.request.mode = campusrover_msgs::PlannerFunction::Request::MODE_GLOBAL_PATH;
          dwa_planner_srv.request.action.data = true;
          dwa_planner_srv.request.obstacle_avoidance.data = true;
          dwa_planner_srv.request.direction_inverse.data = false;
          dwa_planner_srv.request.speed_parameter.linear.x = 0.4;
          dwa_planner_srv.request.speed_parameter.angular.z = 0.4;
          dwa_planner_client_.waitForExistence();
          if (dwa_planner_client_.call(dwa_planner_srv))
          {
            std::cout << "Start DWA Planner" << std::endl;
          }
          else
          {
            std::cerr << "Failed to call DWA Planner Service" << std::endl;
            return;
          }
          call_dwa_enable_srv_ = true;
          call_dwa_disable_srv_ = false;
        }
        return;
      }
      

      if(front_ob_closest_dis <= obstacle_detect_min_dis_)
      {
        len_vel = 0.0;
      }
      else
      {
        // double gan = 10.0*((front_ob_closest_dis-obstacle_detect_min_dis_)/(obstacle_detect_max_dis_ - obstacle_detect_min_dis_));
        // len_vel = len_vel*(round(gan) *0.1);
        len_vel = len_vel*(front_ob_closest_dis-obstacle_detect_min_dis_)/(obstacle_detect_max_dis_ - obstacle_detect_min_dis_);
      }
    }
    else
    {
      if(detect_front_obstacled)
      {
        no_detect_ob_first_time = ros::Time::now();
        detect_front_obstacled = false;
        detect_static_obstacled = false;
      }

      ros::Time time_now = ros::Time::now();
      no_detect_ob_continue_time = time_now.toSec()- no_detect_ob_first_time.toSec();
      // std::cout << "no_detect_ob_continue_time " <<no_detect_ob_continue_time<< std::endl;
      if(no_detect_ob_continue_time > 4.0)
      {
        if(!call_dwa_disable_srv_)
        {
          campusrover_msgs::PlannerFunction dwa_planner_srv;
          dwa_planner_srv.request.mode = campusrover_msgs::PlannerFunction::Request::MODE_GLOBAL_PATH;
          dwa_planner_srv.request.action.data = false;
          dwa_planner_srv.request.obstacle_avoidance.data = true;
          dwa_planner_srv.request.direction_inverse.data = false;
          dwa_planner_srv.request.speed_parameter.linear.x = 0.4;
          dwa_planner_srv.request.speed_parameter.angular.z = 0.4;
          dwa_planner_client_.waitForExistence();
          if (dwa_planner_client_.call(dwa_planner_srv))
          {
            std::cout << "Stop DWA Planner" << std::endl;
          }
          else
          {
            std::cerr << "Failed to call DWA Planner Service" << std::endl;
            return;
          }
          call_dwa_disable_srv_ = true;
          call_dwa_enable_srv_ = false;
        }
      }
      else
      {
        if(!call_dwa_disable_srv_){
          return;
        }
      }
    }
    if(call_dwa_enable_srv_)
    {
      return;
    }
  }
  else
  {
    if(detect_front_obstacle)
    {
      if(front_ob_closest_dis <= obstacle_detect_min_dis_)
      {
        len_vel = 0.0;
      }
      else
      {
        len_vel = len_vel*(front_ob_closest_dis-obstacle_detect_min_dis_)/(obstacle_detect_max_dis_ - obstacle_detect_min_dis_);
      }
    }
  }

  // //-----Pull Over Mode-----//
  // static ros::Time detect_back_ob_first_time;
  // double detect_back_ob_continue_time;
  // static ros::Time no_detect_back_ob_first_time;
  // double no_detect_back_ob_continue_time;

  // if(enble_pullover_mode_)
  // {
  //   static bool call_pullover_srv = false;
  //   //detect obstacle process
  //   if(detect_back_obstacle)
  //   {
  //     if(!detect_back_obstacled)
  //     {
  //       detect_back_ob_first_time = ros::Time::now();
  //       detect_back_obstacled = true;
  //     }

  //     ros::Time time_now = ros::Time::now();
  //     detect_back_ob_continue_time = time_now.toSec()- detect_back_ob_first_time.toSec();
      
  //     std::cout << "detect_back_ob_continue_time " <<detect_back_ob_continue_time<< std::endl;
  //     if(detect_back_obstacled && detect_back_ob_continue_time > 2.0)
  //     {
  //       if(!call_pullover_srv)
  //       {
  //         campusrover_move::PullOverPathGenerator pullover_srv;
  //         pullover_srv.request.pullover_forward_dis = 0.8;
  //         pullover_srv.request.pullover_shift_dis = 0.2;
  //         pullover_srv.request.reference_path = globle_path_;
  //         pullover_planner_client_.waitForExistence();
  //         if (pullover_planner_client_.call(pullover_srv))
  //         {
  //           pullover_path_ = pullover_srv.response.pullover_path;
  //           path_sub_mode_ = campusrover_msgs::PlannerFunction::Request::MODE_PULLOVER_PATH;
  //           UpdateInputPath(pullover_path_);
  //           std::cout << "Start Pull Over Mode" << std::endl;
  //           call_pullover_srv = true;
  //           return;
  //         }
  //         else
  //         {
  //           std::cerr << "Failed to call Pull Over Planner Service" << std::endl;
  //           return;
  //         }
  //       }
  //     }
      
  //   }
  //   else
  //   {
  //     if(detect_back_obstacled)
  //     {
  //       no_detect_back_ob_first_time = ros::Time::now();
  //       detect_back_obstacled = false;
  //     }

  //     ros::Time time_now = ros::Time::now();
  //     no_detect_back_ob_continue_time = time_now.toSec()- no_detect_back_ob_first_time.toSec();
  //     std::cout << "no_detect_back_ob_continue_time " <<no_detect_back_ob_continue_time<< std::endl;
  //     cout<<"detect_back_obstacled: "<<detect_back_obstacled<<endl;
  //     if(call_pullover_srv)
  //     {
  //       if(no_detect_back_ob_continue_time > 3.0)
  //       {
  //         path_sub_mode_ = campusrover_msgs::PlannerFunction::Request::MODE_GLOBAL_PATH;
  //         UpdateInputPath(globle_path_);
  //         std::cout << "Stop Pull Over Mode" << std::endl;
  //         call_pullover_srv = false;
  //         return;
  //       }
  //     }
      
  //   }
  // }

  

  if(closest_id >= following_path_.poses.size() - 1)
  {
    len_vel = len_vel*0.3;
  }

  if(enable_linear_depend_angular_)
  {
    if(abs(yaw_error) >= max_angle_of_linear_profile_)
    {
      len_vel = 0.0;
    }
    else if(abs(yaw_error) >= min_angle_of_linear_profile_ && abs(yaw_error) < max_angle_of_linear_profile_)
    {
      len_vel = len_vel*(1.0-((abs(yaw_error)-min_angle_of_linear_profile_)/max_angle_of_linear_profile_));
    }
  }
  
  //cout<< "direction_yaw : " <<direction_yaw<<" robot_yaw_"<<robot_yaw_ <<" robot_direction_yaw"<<robot_direction_yaw <<" yaw_error"<<yaw_error<<endl;
  double min_reduce_dis = 0.8;
  double target_dist = sqrt(pow(following_path_.poses[following_path_.poses.size()-1].pose.position.x - robot_tf_pose_.position.x, 2) 
                          + pow(following_path_.poses[following_path_.poses.size()-1].pose.position.y - robot_tf_pose_.position.y, 2));
  if(target_dist < min_reduce_dis)
  {
    if(target_dist/min_reduce_dis > 1.0)
    {
      len_vel = max_linear_velocity_;
    }
    else if(target_dist/min_reduce_dis < 0.1)
    {
      len_vel = min_linear_velocity_;
    }
    else
    {
      len_vel = len_vel*(target_dist/min_reduce_dis);
    }
  }
  if(!enble_dwa_obstacle_avoidance_)
  {
    TwistProfile(len_vel, ang_vel);
  }
  TwistPublish(len_vel, ang_vel);
}
//-----------------------------------------------------------------------------------------------
void moving_to_target_direction()
{
  static double yaw_error;
  static double ang_vel;

  yaw_error = target_yaw_ - robot_yaw_;
  angle_normalize(yaw_error);

  ang_vel = yaw_error*speed_pid_k_;
  
  if(ang_vel > 0 && ang_vel < min_angular_velocity_)
  {
    ang_vel = min_angular_velocity_;
  }
  else if(ang_vel < 0 && ang_vel > -min_angular_velocity_)
  {
    ang_vel = -min_angular_velocity_;
  }

  TwistPublish(0.0, ang_vel);
}
//-----------------------------------------------------------------------------------------------
void TwistPublish(double x, double z)
{
  static geometry_msgs::Twist pub_twist;

  if(z > max_angular_velocity_)
  {
    pub_twist.angular.z =max_angular_velocity_;
  }
  else if(z < -max_angular_velocity_)
  {
    pub_twist.angular.z = -max_angular_velocity_;
  }
  else
  {
    pub_twist.angular.z = z;
  }
  
  
  
  pub_twist.linear.x = x;
  
  //make_twist_path(pub_twist.linear.x, pub_twist.angular.z);
  twist_pub_.publish(pub_twist);
}
//-----------------------------------------------------------------------------------------------
void TwistProfile(double &profile_linear_x, double &profile_angular_z)
{
  static double step_linear_x_ = 0.01;
  static double step_angular_z_ = 0.02;
  static double vel_tolerance = 0.015;

  // twist_linear_step_ = current_v_;
  // twist_angular_step_ = current_w_;

  if(abs(profile_linear_x - twist_linear_step_) <=  vel_tolerance)
  {
    twist_linear_step_ = profile_linear_x;
  }
  else
  {
    if (profile_linear_x > twist_linear_step_)
    { 
      twist_linear_step_ = twist_linear_step_ + step_linear_x_;
    }
    else if (profile_linear_x < twist_linear_step_)
    {
      twist_linear_step_ = twist_linear_step_ - step_linear_x_*1.5;
    }
    else
    {
      twist_linear_step_ = profile_linear_x;
    }
  }
  //

  if(abs(profile_angular_z - twist_angular_step_) <=  vel_tolerance)
  {
    twist_linear_step_ = profile_linear_x;
  }
  else
  {
    if (profile_angular_z > twist_angular_step_)
    {
      twist_angular_step_ = twist_angular_step_ + step_angular_z_;
    }
    else if (profile_angular_z < twist_angular_step_)
    {
      twist_angular_step_ = twist_angular_step_ - step_angular_z_;
    }
    else
    {
      twist_angular_step_ = profile_angular_z;
    }
  }

  profile_linear_x = twist_linear_step_;
  profile_angular_z = twist_angular_step_;
}
//-----------------------------------------------------------------------------------------------
void PulloverFunction()
{
  geometry_msgs::PoseStamped globle_path_pose_g;
  geometry_msgs::PoseStamped globle_path_pose_b;
  static tf2_ros::Buffer tfBuffer;
  static tf2_ros::TransformListener tfListener(tfBuffer);
  //seach back of robot obstacles
  int gp_closest_id;
  double dist_fp_p;
  double closest_dist;
  double looking_dist;
  static double ob_dist;
  static double back_ob_closest_dis;
  static int target_point_id;
  static int back_ob_detect_id;

  bool detect_back_obstacle = false;
  static bool detect_back_obstacled = false;

  for (int cp = 0; cp < globle_path_.poses.size(); cp++)
  {
    dist_fp_p = sqrt(pow(robot_tf_pose_.position.x - globle_path_.poses[cp].pose.position.x,2) 
                    + pow(robot_tf_pose_.position.y - globle_path_.poses[cp].pose.position.y,2));
    if (cp == 0)
    {
      closest_dist = dist_fp_p;
      gp_closest_id = cp;
    }
    else if (dist_fp_p < closest_dist)
    {
      closest_dist = dist_fp_p;
      gp_closest_id = cp;
    }
  }

  if(gp_closest_id > 0)
  {
    for(int p = gp_closest_id; p > 0;p--)
    {
      looking_dist = sqrt(pow(globle_path_.poses[p].pose.position.x - robot_tf_pose_.position.x, 2) 
                        + pow(globle_path_.poses[p].pose.position.y - robot_tf_pose_.position.y, 2));
      
      if(looking_dist <= back_obstacle_detect_max_dis_)
      {
        back_ob_detect_id = p;
      }
      else
      {
        break;
      }
    }
  }

  for(int path_count=gp_closest_id; path_count>back_ob_detect_id; path_count--)
  {
    if(detect_back_obstacle){
      break;
    }
    globle_path_pose_g.header.frame_id = globle_path_.header.frame_id;
    globle_path_pose_g.pose.position.x = globle_path_.poses[path_count].pose.position.x;
    globle_path_pose_g.pose.position.y = globle_path_.poses[path_count].pose.position.y;
    globle_path_pose_g.pose.position.z = globle_path_.poses[path_count].pose.position.z;
    try{
      tfBuffer.transform(globle_path_pose_g, globle_path_pose_b, robot_frame_, ros::Duration(2.0));
    }
    catch (tf2::TransformException &ex){
      ROS_WARN("ob : %s", ex.what());
      return;
    }
    for(int ob_count=0; ob_count < obstacle_poses_.poses.size(); ob_count++)
    {
      ob_dist = sqrt(pow(globle_path_pose_b.pose.position.x - obstacle_poses_.poses[ob_count].position.x, 2) 
                    + pow(globle_path_pose_b.pose.position.y - obstacle_poses_.poses[ob_count].position.y, 2));
      
      if(ob_dist < obstacle_range_){
        back_ob_closest_dis = sqrt(pow(globle_path_pose_b.pose.position.x , 2) 
                            + pow(globle_path_pose_b.pose.position.y , 2));;
        
        detect_back_obstacle = true;
        
        // cout<<"closest_id: "<<closest_id<<"front_ob_detect_id: "<<front_ob_detect_id<<"path_count: "<<path_count<<endl;
        break;
      }
    }
  }

  //-----Pull Over Mode-----//
  static ros::Time detect_back_ob_first_time;
  double detect_back_ob_continue_time;
  static ros::Time no_detect_back_ob_first_time;
  double no_detect_back_ob_continue_time;

  static bool call_pullover_srv = false;
  //detect obstacle process
  if(detect_back_obstacle)
  {
    if(!detect_back_obstacled)
    {
      detect_back_ob_first_time = ros::Time::now();
      detect_back_obstacled = true;
    }

    ros::Time time_now = ros::Time::now();
    detect_back_ob_continue_time = time_now.toSec()- detect_back_ob_first_time.toSec();
    
    // std::cout << "detect_back_ob_continue_time " <<detect_back_ob_continue_time<< std::endl;
    if(detect_back_obstacled && detect_back_ob_continue_time > 2.0)
    {
      if(!call_pullover_srv)
      {
        campusrover_move::PullOverPathGenerator pullover_srv;
        pullover_srv.request.pullover_forward_dis = 2.0;
        pullover_srv.request.pullover_shift_dis = 0.55;
        pullover_srv.request.reference_path = globle_path_;
        pullover_planner_client_.waitForExistence();
        if (pullover_planner_client_.call(pullover_srv))
        {
          pullover_path_ = pullover_srv.response.pullover_path;
          path_sub_mode_ = campusrover_msgs::PlannerFunction::Request::MODE_PULLOVER_PATH;
          UpdateInputPath(pullover_path_);
          std::cout << "Start Pull Over Mode" << std::endl;
          call_pullover_srv = true;
          return;
        }
        else
        {
          std::cerr << "Failed to call Pull Over Planner Service" << std::endl;
          return;
        }
      }
    }
  }
  else
  {
    if(detect_back_obstacled)
    {
      no_detect_back_ob_first_time = ros::Time::now();
      detect_back_obstacled = false;
    }

    ros::Time time_now = ros::Time::now();
    no_detect_back_ob_continue_time = time_now.toSec()- no_detect_back_ob_first_time.toSec();
    // std::cout << "no_detect_back_ob_continue_time " <<no_detect_back_ob_continue_time<< std::endl;
    if(call_pullover_srv)
    {
      if(no_detect_back_ob_continue_time > 3.0)
      {
        path_sub_mode_ = campusrover_msgs::PlannerFunction::Request::MODE_GLOBAL_PATH;
        UpdateInputPath(globle_path_);
        std::cout << "Stop Pull Over Mode" << std::endl;
        call_pullover_srv = false;
        arriving_end_point_ = false;
        arriving_end_direction_ = false;
        return;
      }
    }
  }
  

}
//-----------------------------------------------------------------------------------------------
void UpdateInputPath(const nav_msgs::Path &path)
{
  static geometry_msgs::PoseStamped pose;
  double roll, pitch, yaw;

  get_following_path_ = false;
  following_path_.poses.clear();

  if(path.poses.size() == 0)
    return;
  
  if(path.header.stamp.toSec() < planner_start_time.toSec() && path_sub_mode_ == campusrover_msgs::PlannerFunction::Request::MODE_ELEVATOR_PATH)
    return;

  following_path_.header.frame_id = path.header.frame_id;

  following_path_.poses.clear();

  following_path_ = path;

  // if(path_sub_mode_ != campusrover_msgs::PlannerFunction::Request::MODE_PULLOVER_PATH)
  // {
  target_pose_.header.frame_id = path.header.frame_id;
  target_pose_.pose.position = path.poses[path.poses.size()-1].pose.position;
  target_pose_.pose.orientation = path.poses[path.poses.size()-1].pose.orientation;

  tf::Quaternion q( target_pose_.pose.orientation.x,
                    target_pose_.pose.orientation.y,
                    target_pose_.pose.orientation.z,
                    target_pose_.pose.orientation.w);
  tf::Matrix3x3 m(q);

  m.getRPY(roll, pitch, yaw);
  target_yaw_ = yaw;
  // }
  

  get_following_path_ = true;

}
//-----------------------------------------------------------------------------------------------
void angle_normalize(double &angle)
{
  if(angle > M_PI)
  {
    angle = -2*M_PI + angle;
  }else if(angle < -M_PI)
  {
    angle = 2*M_PI + angle;
  }
}
//-----------------------------------------------------------------------------------------------
void ElevatorPathCallback(const nav_msgs::Path &path)
{ 
  static geometry_msgs::PoseStamped pose;
  static double roll, pitch, yaw;

  if(path_sub_mode_ != campusrover_msgs::PlannerFunction::Request::MODE_ELEVATOR_PATH)
  {
    return;
  }

  if(path.poses.size()==0)
  {
    return;
  }

  elevator_path_.header.frame_id = path.header.frame_id;

  elevator_path_.poses.clear();

  elevator_path_ = path;

  UpdateInputPath(elevator_path_);
  
}
//-----------------------------------------------------------------------------------------------
void GlobalPathCallback(const nav_msgs::Path &path)
{
  static geometry_msgs::PoseStamped pose;
  static double roll, pitch, yaw;

  // if(path_sub_mode_ != campusrover_msgs::PlannerFunction::Request::MODE_GLOBAL_PATH)
  // {
  //   return;
  // }

  if(path.poses.size()==0)
    return;

  globle_path_.header.frame_id = path.header.frame_id;

  globle_path_.poses.clear();

  globle_path_ = path;

  if(path_sub_mode_ == campusrover_msgs::PlannerFunction::Request::MODE_GLOBAL_PATH)
  {
    UpdateInputPath(globle_path_);
  }
  
}
//-----------------------------------------------------------------------------------------------
void CostmapCallback(const nav_msgs::OccupancyGridConstPtr &map)
{
  geometry_msgs::Pose ob_pose;
  geometry_msgs::PoseStamped ob_posestamped;
  geometry_msgs::PoseStamped base_ob_pose;
  static tf2_ros::Buffer tfBuffer;
  static tf2_ros::TransformListener tfListener(tfBuffer);
  static geometry_msgs::TransformStamped transformStamped;
  double data;
  double value;

  if(!enble_costmap_obstacle_)
    return;

  costmap_data_.info.resolution = map->info.resolution;
  obstacle_poses_.poses.clear();

  if (map->header.frame_id == robot_frame_)
  {
    for (int i = 0; i < map->data.size(); i++)
    {
      data = map->data[i];
      value = i;

      if (std::abs(data) > threshold_occupied_)
      {
        ob_pose.position.y = (std::floor(value / map->info.width) * map->info.resolution) + map->info.origin.position.y;
        ob_pose.position.x = ((value - (map->info.width * std::floor(value / map->info.width))) * map->info.resolution) + map->info.origin.position.x;

        if (ob_pose.position.x < footprint_max_x_ && ob_pose.position.x > footprint_min_x_ && ob_pose.position.y < footprint_max_y_ && ob_pose.position.y > footprint_min_y_)
        {
          obstacle_stop_cmd_ = true;
          status_msg_ = 3;
          break;
        }
        else
        {
          obstacle_stop_cmd_ = false;
        }
        obstacle_poses_.poses.push_back(ob_pose);
        // std::cout << "i : " << i<< " data : "<< data<< " x : " << ob_pose.position.x<<" y : " << ob_pose.position.y<<'\n';
      }
    }
  }
  else
  {
    ob_posestamped.header.frame_id = map->header.frame_id;

    for (int i = 0; i < map->data.size(); i++)
    {
      data = map->data[i];

      if (std::abs(data) > threshold_occupied_)
      {

        value = i;

        ob_posestamped.pose.position.y = (std::floor(value / map->info.width) * map->info.resolution) + map->info.origin.position.y;
        ob_posestamped.pose.position.x = ((value - (map->info.width * std::floor(value / map->info.width))) * map->info.resolution) + map->info.origin.position.x;

        try
        {
          tfBuffer.transform(ob_posestamped, base_ob_pose, robot_frame_, ros::Duration(2.0));
        }
        catch (tf2::TransformException &ex)
        {
          ROS_WARN("ob : %s", ex.what());
          return;
        }

        ob_pose.position.y = base_ob_pose.pose.position.y;
        ob_pose.position.x = base_ob_pose.pose.position.x;

        if (ob_pose.position.x < footprint_max_x_ && ob_pose.position.x > footprint_min_x_ && ob_pose.position.y < footprint_max_y_ && ob_pose.position.y > footprint_min_y_)
        {
          obstacle_stop_cmd_ = true;
          status_msg_ = 3;
          break;
        }
        else
        {
          obstacle_stop_cmd_ = false;
        }
        obstacle_poses_.poses.push_back(ob_pose);

        //std::cout << "i : " << i<< " data : "<< data<< " x : " << ob_pose.position.x<<" y : " << ob_pose.position.y<<'\n';
      }
    }
  }

  // for(int t=0;t<obstacle_poses_.poses.size();t++)
  // {
  //   cout<<"x: "<<obstacle_poses_.poses[t].position.x<<" y: "<<obstacle_poses_.poses[t].position.y<<endl;
  // }
  // cout<<"======================"<<endl;

  get_costmap_data_ = true;
}
//-----------------------------------------------------------------------------------------------
void OdomCallback(const nav_msgs::OdometryConstPtr &odom)
{
  current_v_ = odom->twist.twist.linear.x;
  current_w_ = odom->twist.twist.angular.z;

  if(get_velocity_data_ == false){
    ROS_INFO("path following : Get the Odom input!!");
  }
  get_velocity_data_ = true;

}
//-----------------------------------------------------------------------------------------------
void CB_customObstacle(const costmap_converter::ObstacleArrayMsg::ConstPtr& obst_msg)
{
  static tf2_ros::Buffer tfBuffer;
  static tf2_ros::TransformListener tfListener(tfBuffer);
  geometry_msgs::Pose ob_pose;
  geometry_msgs::PoseStamped obstacle_r;
  geometry_msgs::PoseStamped obstacle_g;

  obstacle_poses_.poses.clear();

  if (obst_msg->header.frame_id == robot_frame_)
  {
    for(int i=0; i<obst_msg->obstacles.size();i++)
    {
      ob_pose.position.x = obst_msg->obstacles[i].polygon.points[0].x;
      ob_pose.position.y = obst_msg->obstacles[i].polygon.points[0].y;    

      obstacle_poses_.poses.push_back(ob_pose);
    }
  }
  else
  {
    for(int i=0; i<obst_msg->obstacles.size();i++)
    {

      obstacle_g.header.frame_id = obst_msg->obstacles[i].header.frame_id;
      obstacle_g.pose.position.x = obst_msg->obstacles[i].polygon.points[0].x;
      obstacle_g.pose.position.y = obst_msg->obstacles[i].polygon.points[0].y;
      try
      {
        tfBuffer.transform(obstacle_g, obstacle_r, robot_frame_, ros::Duration(2.0));
      }
      catch (tf2::TransformException &ex)
      {
        ROS_WARN("ob : %s", ex.what());
        return;
      }

      ob_pose.position.x = obstacle_r.pose.position.x;
      ob_pose.position.y = obstacle_r.pose.position.y;    

      obstacle_poses_.poses.push_back(ob_pose);
    }
    
    
  }
  

  get_obstacle_data_ = true;
}
//-----------------------------------------------------------------------------------------------
bool ServiceCallback(campusrover_msgs::PlannerFunction::Request  &req, campusrover_msgs::PlannerFunction::Response &res)
{
  static int last_mode;
  // if (req.mode == campusrover_msgs::PlannerFunction::Request::MODE_GLOBAL_PATH)
  // {
    

  // }
  // else if((req.mode == campusrover_msgs::PlannerFunction::Request::MODE_ELEVATOR_PATH))
  // {
    
  // }
  
  //ros::Duration(1.0).sleep();
  action_flag_ = req.action.data;
  direction_inverse_ = req.direction_inverse.data;
  enble_costmap_obstacle_ = req.obstacle_avoidance.data;
  max_linear_velocity_ = req.speed_parameter.linear.x;
  max_angular_velocity_ = std::abs(req.speed_parameter.angular.z);
  active_angular_ = req.speed_parameter.angular.z;

  path_sub_mode_ = req.mode;

  cout << "recrvie planner fuction : " << endl;
  cout << "  action_flag : " <<action_flag_<< endl;
  cout << "  direction_inverse : " <<direction_inverse_<< endl;
  cout << "  enble_costmap_obstacle_ : " <<enble_costmap_obstacle_<< endl;
  cout << "  speed fuction : " <<req.speed_parameter<< endl;
  //
  if(!action_flag_ || path_sub_mode_ != last_mode)
  {
    arriving_end_point_ = false;
    arriving_end_direction_ = false;
    // get_globle_path_ = false;
    get_costmap_data_ = false;
    twist_linear_step_ = 0;
    twist_angular_step_ = 0;
  }

  planner_start_time = ros::Time::now();

  if(path_sub_mode_ == campusrover_msgs::PlannerFunction::Request::MODE_GLOBAL_PATH)
  {
    UpdateInputPath(globle_path_);
  }
  else if(path_sub_mode_ == campusrover_msgs::PlannerFunction::Request::MODE_ELEVATOR_PATH)
  {
    UpdateInputPath(elevator_path_);
  }
  else if(path_sub_mode_ == campusrover_msgs::PlannerFunction::Request::MODE_PULLOVER_PATH)
  {
    UpdateInputPath(pullover_path_);
  }

  if(!enble_costmap_obstacle_)
  {
    obstacle_poses_.poses.clear();
  }
  
  last_mode = path_sub_mode_;
  
  return true;

  
}
//-----------------------------------------------------------------------------------------------
void ElevatorStatusCheckCallService(ros::ServiceClient &client,campusrover_msgs::ElevatorStatusChecker &srv)
{
  ros::Duration(1.5).sleep();
  string str = "===========elevator planner status check============= " ;
  cout << "Request massage: \n" << srv.request;
  while (!client.call(srv))
  {
    ROS_ERROR("elevator planner status check : Failed to call service");
    ros::Duration(1.0).sleep();
  }
}
//-----------------------------------------------------------------------------------------------
int main(int argc, char **argv)
{
  ros::init(argc, argv, "path_following");
  ros::NodeHandle nh;
  ros::NodeHandle nh_private("~");
  get_parameters(nh_private);
  ros::Time::init();
  
  elevator_path_sub_ = nh.subscribe("elevator_path", 10, ElevatorPathCallback);
  global_path_sub_ = nh.subscribe("global_path", 10, GlobalPathCallback);
  costmap_sub_ = nh.subscribe("costmap", 10, CostmapCallback);
  odom_sub_ = nh.subscribe("odom", 10, OdomCallback);
  custom_obst_sub_ = nh.subscribe("obstacles", 1, CB_customObstacle);
  
  twist_pub_ = nh.advertise<geometry_msgs::Twist>("cmd_vel", 50);

  twist_path_pub_ = nh.advertise<nav_msgs::Path>("twist_path", 20);
  path_marker_pub_ = nh.advertise<visualization_msgs::MarkerArray>("local_trajectories", 10);

  global_status_check_pub_ = nh.advertise<std_msgs::Empty>("reach_goal", 20);

  ros::Timer timer = nh.createTimer(ros::Duration(0.02), TimerCallback);
  ros::Timer msgs_timer = nh.createTimer(ros::Duration(2), msgs_timerCallback);

  ros::ServiceServer service = nh.advertiseService("planner_function", ServiceCallback);
  elevator_status_check_client_ = nh.serviceClient<campusrover_msgs::ElevatorStatusChecker>("elevator_status_checker");
  dwa_planner_client_ = nh.serviceClient<campusrover_msgs::PlannerFunction>("planner_function_dwa");
  pullover_planner_client_ = nh.serviceClient<campusrover_move::PullOverPathGenerator>("generate_pullover_path");
  ros::spin();

  return 0;
}

